package  {	import flash.net.URLLoader;	import flash.net.URLRequest;	import flash.events.Event;	import flash.events.IOErrorEvent;	import flash.display.Loader;	import flash.display.Bitmap;	import flash.display.Sprite;			public class XMLLoader extends Sprite {		public var myXML:XML;		private var fileName:String;		private var index:int = 0;		private var lastInc:int;				public var randomMode:Boolean = false;		public var completedXML:Boolean = false;		public var completed:Boolean = false;		public var completedBG:Boolean = false;		public var errorMsg:String = "";		public var bitmapArray:Array = [];		public var imageCardX:Number;		public var imageCardY:Number;		public var imgCounter:Number = 1;				//private var myLoader:URLLoader;		//private var loader:Loader;						public function XMLLoader() {			// constructor code		}						public function openFile(fName:String):void {			fileName = fName;			var myLoader:URLLoader = new URLLoader();			myLoader.load( new URLRequest( fileName ) );			completedXML = false;			myLoader.addEventListener(Event.COMPLETE, processXML);			myLoader.addEventListener(IOErrorEvent.IO_ERROR, errorOpeningXML);		}						private function processXML(e:Event):void {			completedXML = true;			myXML = new XML(e.target.data);		}						private function errorOpeningXML(e:IOErrorEvent):void {			errorMsg = "ERROR OPENING";		}						// loadImage(+1) loads NEXT		// loadImage(-1) loads PREV		public function loadImageXML(ind:int = 0):String {			trace("loadImageXML CALLED")						// Rememeber the Increment(+1 or -1)			lastInc = ind;			var imageTitle:String = new String;			// Random?			/*			if (randomMode) {				var oldIndex:int = index;				index = Math.floor(Math.random() * myXML.IMAGES.IMAGE.length());				// Don't repeat the last image				if (index == oldIndex) {					index = (index + ind) % myXML.IMAGES.IMAGE.length();				}			// Sequential order			} else {*/								if (ind == 0 ){					loadImage( myXML.PRACTICE.IMAGE[0] );					imageCardX = Number(myXML.PRACTICE.IMAGE[0].@CARDTILEX);					imageCardY = Number(myXML.PRACTICE.IMAGE[0].@CARDTILEY);					imageTitle = myXML.PRACTICE.IMAGE[0].@TITLE;				}				else if (ind == 1){				//if (ind < 0) {					//ind += myXML.IMAGES.IMAGE.length();					if (imgCounter == Number(myXML.IMAGES.IMAGE.length()+1)){						imgCounter = 1;										}					index = imgCounter-1					loadImage( myXML.IMAGES.IMAGE[index] );					imageCardX = Number(myXML.IMAGES.IMAGE[index].@CARDTILEX);					imageCardY = Number(myXML.IMAGES.IMAGE[index].@CARDTILEY);					//trace("imageCardTile "+imageCardTile)					imageTitle = myXML.IMAGES.IMAGE[index].@TITLE;					imgCounter++					trace("imgCounter "+imgCounter)				}			//}						// Load the image			//loadImage( myXML.IMAGES.IMAGE[index] );			completed = false;			//completedBG = false;										//trace("Image is: " + imageName);			return imageTitle;		}				public function setCardTile ():Object {						//return imageCardTile;			 return {cardX:imageCardX ,cardY:imageCardY}		}						public function loadImage(path:String, bitmapPos:int = 0 ):void {			if (bitmapPos == 0) completed = false;			else completedBG = false;						trace("loading:", path);						//bitmapIndex = bitmapPos;			var loader:Loader = new Loader();			var req:URLRequest = new URLRequest(path);			loader.contentLoaderInfo.addEventListener(Event.COMPLETE, onCompleteLoadImage);			loader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, errorOpeningImage);			loader.load(req);			loader.alpha = bitmapPos;		}						private function onCompleteLoadImage(e:Event):void {			var bitmapIndex:int = e.target.loader.alpha;			bitmapArray[bitmapIndex] = e.target.loader.content as Bitmap;			bitmapArray[bitmapIndex].smoothing = true;						if (bitmapIndex == 0) completed = true;			else completedBG = true;						trace("image loaded!", bitmapIndex);		}						private function errorOpeningImage(e:IOErrorEvent):void {			// Try next image!			trace("image not exists!");			loadImageXML( lastInc );		}						}	}