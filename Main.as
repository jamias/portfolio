package  {	import flash.display.Sprite;	import flash.display.MovieClip;	import flash.events.MouseEvent;	import flash.display.Stage;	import flash.events.Event;	import flash.utils.getTimer;	//import flash.utils.Timer;    //import flash.events.TimerEvent;	import flash.system.Capabilities;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.geom.Rectangle;	import flash.geom.Point;	import flash.geom.Matrix3D;	import flash.geom.PerspectiveProjection;	import flash.utils.*;		import fl.motion.Color;	import fl.transitions.Tween;	import fl.transitions.easing.*;	import fl.transitions.TweenEvent;	import flash.text.TextField;	import flash.text.TextFormat;	import flash.system.System;		import flash.events.NetStatusEvent; 	import flash.events.AsyncErrorEvent;    import flash.media.Video;	import flash.net.*;    import flash.net.NetConnection;    import flash.net.NetStream;		import com.greensock.*;	import com.greensock.easing.*;	import com.greensock.plugins.TweenPlugin; 	import com.greensock.plugins.BlurFilterPlugin; 	import com.greensock.plugins.ColorMatrixFilterPlugin;	import com.greensock.plugins.VisiblePlugin; 	import flash.media.Sound;	import flash.media.SoundTransform;	import flash.media.SoundChannel;		TweenPlugin.activate([BlurFilterPlugin,ColorMatrixFilterPlugin,VisiblePlugin]); //activation is permanent in the SWF, so this line only needs to be run once. ColorTransformPlugin					public class Main extends Sprite {				private var XML_MODE:Boolean = true;	// Load parameters from XML (true) or Default Mode (false)				// CUSTOMIZE PUZZLE		private var TOTAL_PIECES:uint = 9;		private var PUZZLE_ROWS:int = 3;		private var PUZZLE_COLS:int = 3;		private var RANDOM_ROWCOLS:Boolean = false;		// If true, Rows and Cols will be different every play				//private var BG_COLOR:int = 0xa0917f;			// Background Colour		private var BG_WALLPAPER:String;				// Path to show a Background Image		private var BG_WALLPAPERPER_ALPHA:Number = 0;	// Wallpaper alpha (ranging from 0-1)		private var RANDOM_IMG:Boolean = false;			// Randomize Image Order				private const PUZZLE_WIDTH:int = 1000;		// Puzzle Image Width & Height		private const PUZZLE_X:uint = (stage.stageWidth/2) - PUZZLE_WIDTH/2;			// Start position X of Puzzle		private const PUZZLE_Y:uint = 420;			// Start position Y of Puzzle		private const PIECE_MARGIN:Number = 3;		// Separation between pieces		private var TIME_SLIDING:Number = 0.2;			// Seconds to Slide a Piece		private var ALPHA_HINT_WOOD:Number = 0;		// Alpha of the Hint Image (on the Wood)		//private var KEY_HOLD_TIME:int = 150;			// Time(ms) a Key Down will be the same as Down+Down				private var SHOW_DIFFICULTY_BTNS:Boolean = true; //Show/Hide Difficulty Buttons		private var SHOW_PREV_NEXT_BTNS:Boolean = false;  //Show/Hide Prev and Next btns		private var SHOW_SCORES:Boolean = true;			 // Show/Hide Scores				private var MISSING_PIECE:String = "BOTTOM_RIGHT";	// TOP_LEFT / BOTTOM_RIGHT				// END OF CUSTOMIZE						// DONT CHANGE THESE VARs		//private const _KEY_UP:uint = 38;      // Key "UP"		//private const _KEY_DOWN:uint = 40;    // Key "DOWN"		//private const _KEY_LEFT:uint = 37;    // Key "LEFT"		//private const _KEY_RIGHT:uint = 39;   // Key "RIGHT"		//private var _keysPressed:Array = new Array();		//private var _keysDown:Array = new Array();				private var puzzle:Array;		private var pieceHolder:Sprite = new Sprite();		private var puzzleHolder:Sprite = new Sprite();		private var hintHolder:Sprite = new Sprite();			// RIGHT, DOWN, LEFT, UP		private var moveArray:Array = new Array (false, false, false, false);				private var pieceTemp:piece_mc = new piece_mc();		private var wood:wood_mc = new wood_mc();		private var puzzleImage:puzzleImage_mc = new puzzleImage_mc();		private var ui:ui_mc = new ui_mc();		private var winPopUp:popUpWin_mc = new popUpWin_mc();				private var missingPiece:int = 0;		private var diffLevel:String;			//Difficulty Level		private var win:Boolean = false;		private var timeOut:Boolean = false;		private var quit:Boolean = false;		private var gameStarted:Boolean = false;		private var timerStart:int;		private var totalTimer:int;		private var totalMovs:int;		private var lastMovTime:int;		private var timeLimit:int;		private var hintLabel:TextField;				private var xmlLoader:XMLLoader = new XMLLoader();					private var bitmap:Bitmap;		private var imageName:String;		private var cardCoord:Object;			private var cardTileX:Number;				private var cardTileY:Number;					//private var myTween:Tween;		private var sliding:Boolean = false;		private var dragOrigX:Number;		private var mouseOrigX:Number;		private var distance:Number;						private var shuffleTweens:Array = new Array();		private var shuffleTl:TimelineLite = new TimelineLite();		private var timerPulseTl:TimelineMax = new TimelineMax();		private var introTl:TimelineLite = new TimelineLite();		private var setupTl:TimelineLite = new TimelineLite();		private var levelTl:TimelineLite = new TimelineLite();		private var lockTl:TimelineLite = new TimelineLite();		private var gameTl:TimelineLite = new TimelineLite();		private var winTl:TimelineLite = new TimelineLite();		private var findCardTl:TimelineLite = new TimelineLite();		private var endTl:TimelineLite = new TimelineLite();				private var ease1:Ease = Expo.easeIn;		private var ease2:Ease = Expo.easeOut;		private var time:Number = .5;						private var easyJumble:Array = [[4,1,2,5],[2,1,4,3],[4,3,0,1],[2,1,0,3]];						//30 MOVES  ,  30,  30  ,  30, 30  ,30		//private var medJumble:Array = [[7,4,1,0,3,4,7,6,3,0,1,4,5,2,1,4,5,8,7,6,3,4,1,0,3,4,5,2,1,4],[7,4,3,6,7,8,5,2,1,0,3,4,5,2,1,4,7,6,3,4,1,2,5,8,7,4,3,6,7,4],[5,4,3,0,1,2,5,4,1,0,3,4,7,6,3,0,1,2,5,4,1,2,5,8,7,4,3,6,7,4],[7,4,5,2,1,4,5,8,7,4,3,6,7,8,5,2,1,4,7,6,3,4,5,2,1,0,3,4,5,2],[5,4,1,0,3,4,7,6,3,4,7,8,5,4,1,0,3,4,7,6,3,0,1,2,5,4,7,8,5,4],[5,4,7,6,3,4,1,2,5,8,7,6,3,0,1,4,3,0,1,2,5,8,7,6,3,4,1,2,5,4]];								//20 MOVES		//private var medJumble:Array = [[7,4,1,0,3,4,7,6,3,0,1,4,5,2,1,4,5,8,7,6],[7,4,3,6,7,8,5,2,1,0,3,4,5,2,1,4,7,6,3,4],[5,4,3,0,1,2,5,4,1,0,3,4,7,6,3,0,1,2,5,4],[7,4,5,2,1,4,5,8,7,4,3,6,7,8,5,2,1,4,7,6],[5,4,1,0,3,4,7,6,3,4,7,8,5,4,1,0,3,4,7,6],[5,4,7,6,3,4,1,2,5,8,7,6,3,0,1,4,3,0,1,2]];						//20-15 MOVES MIXED		//private var medJumble:Array = [[7,4,1,0,3,4,7,6,3,0,1,4,5,2,1],[7,4,3,6,7,8,5,2,1,0,3,4,5,2,1,4,7,6,3,4],[5,4,3,0,1,2,5,4,1,0,3,4,7,6,3],[7,4,5,2,1,4,5,8,7,4,3,6,7,8,5,2,1,4,7,6],[5,4,1,0,3,4,7,6,3,4,7,8,5,4,1],[5,4,7,6,3,4,1,2,5,8,7,6,3,0,1,4,3,0,1,2]];						//15 MOVES		private var medJumble:Array = [[7,4,1,0,3,4,7,6,3,0,1,4,5,2,1],[7,4,3,6,7,8,5,2,1,0,3,4,5,2,1],[5,4,3,0,1,2,5,4,1,0,3,4,7,6,3],[7,4,5,2,1,4,5,8,7,4,3,6,7,8,5],[5,4,1,0,3,4,7,6,3,4,7,8,5,4,1],[5,4,7,6,3,4,1,2,5,8,7,6,3,0,1]];								//12 MOVES		//private var medJumble:Array = [[7,4,1,0,3,4,7,6,3,0,1,4],[7,4,3,6,7,8,5,2,1,0,3,4],[5,4,3,0,1,2,5,4,1,0,3,4],[7,4,5,2,1,4,5,8,7,4,3,6],[5,4,1,0,3,4,7,6,3,4,7,8],[5,4,7,6,3,4,1,2,5,8,7,6]];								//10 MOVES		//private var medJumble:Array = [[7,4,1,0,3,4,7,6,3,0],[7,4,3,6,7,8,5,2,1,0],[5,4,3,0,1,2,5,4,1,0],[7,4,5,2,1,4,5,8,7,4],[5,4,1,0,3,4,7,6,3,4],[5,4,7,6,3,4,1,2,5,8]];								//8 MOVES		//private var medJumble:Array = [[7,4,1,0,3,4,7,6],[7,4,3,6,7,8,5,2],[5,4,3,0,1,2,5,4],[7,4,5,2,1,4,5,8],[5,4,1,0,3,4,7,6],[5,4,7,6,3,4,1,2]];						//6 MOVES		//private var medJumble:Array = [[7,4,1,0,3,4],[7,4,3,6,7,8],[5,4,3,0,1,2],[7,4,5,2,1,4],[5,4,1,0,3,4],[5,4,7,6,3,4]];										//#4 [5,4,3,0,1,2,5,4]		//#6 [5,4,7,6,3,0,1,2]						//jumble counters for all difficulty levels		private var currentJumble:Array = [easyJumble.length-1,medJumble.length-1] 		private var chosenJumble:Array;				private var cardSlider:MovieClip;		private var sliderOrigX:int ;		private var sliderOrigY:int ;		private var	sliderWidth:int;		private var nc:NetConnection = new NetConnection(); 		private var ns:NetStream;		private var vid:Video;				private var lockPrnt1OrigX:Number;		private var lockPrnt2OrigX:Number;				private var sndBtnClick:Sound = new Sound;		private var sndBtnSlide:Sound = new Sound;		private var sndTileTap:Sound = new Sound;		private var sndTileTap2:Sound = new Sound;		private var sndTileTap3:Sound = new Sound;		private var sndTileTap4:Sound = new Sound;		private var sndTileTap5:Sound = new Sound;		private var sndGameGo:Sound = new Sound;		//private var sndTrans:Sound = new Sound;		private var sndHint:Sound = new Sound;		private var sndLock:Sound = new Sound;		private var sndTimer:Sound = new Sound;		private var sndChTimer:SoundChannel;		private var sndWin:Sound = new Sound;		private var sndTimeOut:Sound = new Sound;		private var sndFoundCard:Sound = new Sound;				private var pulseAlready:Boolean = false;;		private var time_interval:Number;		private var reset_interval:Number;						public function Main() {			addEventListener(Event.ADDED_TO_STAGE, onAddedToStage);			introscreen.cta_begin.addEventListener(MouseEvent.MOUSE_DOWN, setup);			resetBtn.addEventListener(MouseEvent.CLICK, onClickReset);			//introscreen.cta_begin.addEventListener(MouseEvent.CLICK, gameScreen);						cardSlider = setupScreen.mobile.slider;			trace("cardSlider "+cardSlider)			sliderOrigX = cardSlider.x;			sliderOrigY = cardSlider.y;			sliderWidth = cardSlider.width;			lockPrnt1OrigX = lockParent1.x;			lockPrnt2OrigX = lockParent2.x;									//BG VIDEO			nc = new NetConnection(); 			nc.connect(null);			ns = new NetStream(nc); 			ns.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler); 			ns.play("assets/CBSE0366_1480x1920.mp4"); 			function asyncErrorHandler(event:AsyncErrorEvent):void 			{ 				// ignore error 			}						ns.addEventListener(NetStatusEvent.NET_STATUS, statusHandler); 				function statusHandler(event:NetStatusEvent):void 				{ 					switch (event.info.code) 					{ 						case "NetStream.Play.Start": 							//trace("Start [" + ns.time.toFixed(3) + " seconds]"); 							trace("PLAYING");							time_interval = setInterval(checkTime, 500, ns);							break; 						case "NetStream.Play.Stop": 							//trace("Stop [" + ns.time.toFixed(3) + " seconds]"); 							ns.seek(0);							break; 						case "NetStream.Buffer.Full":							trace("VIDEO BUFFER FULL");							break;						case "NetStream.Unpause.Notify":							trace("RESUME VIDEO");							time_interval = setInterval(checkTime, 500, ns);							break;						case "NetStream.Pause.Notify":							trace("PAUSED VIDEO");							clearInterval(time_interval);							break;					} 				}						var videoVol:SoundTransform = new SoundTransform();    		videoVol.volume = 0;    		ns.soundTransform = videoVol;			//ns.pause();						vid= new Video(); 			vid.attachNetStream(ns); 			vid.height = 1920;			vid.width = 1480;			vid.x=-200;			//vid.mute();			bg.addChildAt(vid,1);						loadSounds();									 			introTween();					}						private function checkTime(my_ns:NetStream) {				var ns_seconds:Number = my_ns.time;				trace(ns_seconds)				//var minutes:Number = Math.floor(ns_seconds/60);				//var seconds = Math.floor(ns_seconds%60);				if (ns_seconds>=23.50) {					trace("VIDEO END NEAR")					ns.seek(0);						introscreen.logo.gotoAndPlay(1);				}			}		private function loadSounds(){			sndBtnClick.load(new URLRequest("sfx/BtnClick.mp3"));			sndBtnSlide.load(new URLRequest("sfx/cardSwipe.mp3"));			sndGameGo.load(new URLRequest("sfx/gameSetup.mp3"));			sndTileTap.load(new URLRequest("sfx/movingTiles_01.mp3"));			sndTileTap2.load(new URLRequest("sfx/movingTiles_02.mp3"));			sndTileTap3.load(new URLRequest("sfx/movingTiles_03.mp3"));			sndTileTap4.load(new URLRequest("sfx/movingTiles_04.mp3"));			sndTileTap5.load(new URLRequest("sfx/movingTiles_05.mp3"));			//sndTrans.load(new URLRequest("sfx/button1.mp3"));			sndHint.load(new URLRequest("sfx/Hint.mp3"));			sndLock.load(new URLRequest("sfx/card_lock.mp3"));			sndTimer.load(new URLRequest("sfx/countDown_Crowd.mp3"));			sndWin.load(new URLRequest("sfx/Win.mp3"));			sndTimeOut.load(new URLRequest("sfx/timeOut.mp3"));			sndFoundCard.load(new URLRequest("sfx/cardHighlight.mp3"));						sndChTimer = sndTimer.play();			sndChTimer.stop();		}				private function playSound(snd:Sound){			snd.play();		}		private function stopSound(snd:Sound){			//snd.stop();		}				public function reset(){			removeChild(hintHolder);			removeChild(puzzleHolder);			removeChild(pieceHolder);			removeChild(ui);			removeChild(wood);						introTl.kill();			setupTl.kill();			levelTl.kill();			lockTl.kill();			gameTl.kill();			winTl.kill();			findCardTl.kill();			endTl.kill();			timerPulseTl.kill();											introscreen.logo.alpha = 0;			introscreen.x=0;			setupScreen.mobile.scaleX=1;			setupScreen.mobile.scaleY=1;			setupScreen.mobile.alpha=1;			introscreen.visible=true;			setupScreen.alpha = 1;			setupScreen.visible=false;			introscreen.cta_begin.addEventListener(MouseEvent.CLICK, setup);			introTween();			setupScreen.cardBtn.alpha=1;			setupScreen.cardBtn.scaleX= setupScreen.cardBtn.scaleY= 1;			//setupScreen.cardScreen.dotPractise.gotoAndPlay("on");			//setupScreen.cardScreen.dotPlay.gotoAndPlay("off");						TweenLite.killTweensOf(cardSlider);			cardSlider.x = sliderOrigX;			lockParent1.gotoAndStop(1);			lockParent2.gotoAndStop(1);			lockParent1.alpha = lockParent2.alpha = 1;			lockParent1.x = lockPrnt1OrigX;			lockParent2.x =lockPrnt2OrigX;						//bg.vidPlayer.seek(sec);			//ns.seek(sec);						TweenLite.to(bg.getChildAt(1),.5,{blurFilter:{blurX:0, blurY:0, quality:1, remove:true}, onComplete:vidPlay});						function vidPlay(){				ns.resume();			}											}				public function setup(e:MouseEvent):void {			playSound(sndBtnClick);			introscreen.cta_begin.gotoAndPlay("on")			introscreen.cta_begin.removeEventListener(MouseEvent.MOUSE_DOWN, setup);						//pauseVideo();			ns.pause();			setupScreen.cardBtn.visible = false;			setupScreen.mobile.cardScreen.visible = false;			cardSlider.visible = false;			setupScreen.txt2.alpha=0;			setupScreen.cardBtn.visible = true;			setupScreen.cardBtn.addEventListener(MouseEvent.CLICK, chooseLevel);			setupScreen.cardBtn.gotoAndPlay(2);					//setupScreen.visible=true;									setupTl = new TimelineLite;						setupTl.addLabel("begin",0.1);			setupTl.to(bg.getChildAt(1),.3,{blurFilter:{blurX:60, blurY:60, quality:1}},"begin");			setupTl.fromTo(introscreen,time,{x:0, ease:ease1, immediateRender:true},{x:1080, visible:false, ease:ease2},"begin+=.2");						//Parallax Video			//setupTl.fromTo(bg.getChildAt(1),time,{x:-200,ease:ease1},{x:-100,ease:ease2},"begin+=.2");			setupTl.fromTo(introscreen,time,{x:0, ease:ease1, immediateRender:true},{x:1080, visible:false, ease:ease2},"begin+=.2");						setupTl.fromTo(setupScreen,time,{x:-1080,visible:true, ease:ease1},{x:0, ease:ease2},"begin+=.2");									setupTl.fromTo(setupScreen.txt1,.5,{alpha:0, immediateRender:true},{alpha:1},"begin+=.3");											}				public function chooseLevel(e:MouseEvent):void {			playSound(sndBtnClick);			levelTl = new TimelineLite();			levelTl.addLabel("begin",0);			levelTl.add(TweenLite.fromTo(setupScreen.cardBtn,.5,{colorMatrixFilter:{colorize:0xffffff, amount:1,brightness:2},alpha:1, scaleX:1,scaleY:1, ease:Back.easeIn},{colorMatrixFilter:{colorize:0xffffff, amount:1,brightness:2},alpha:1,ease:ease2, scaleX:1.66,scaleY:1.66}) );			levelTl.add(TweenLite.fromTo(setupScreen.cardBtn,.25,{alpha:1,colorMatrixFilter:{colorize:0xffffff, amount:1,brightness:2}},{alpha:0, visible:false,colorMatrixFilter:{colorize:0xffffff, amount:1,brightness:2,remove:true}}));			levelTl.add(TweenLite.fromTo(setupScreen.txt1,.5,{alpha:1},{alpha:0}),"begin" );			levelTl.add(TweenLite.fromTo(setupScreen.txt2,.5,{alpha:0, x:142-150, immediateRender:true, ease:ease1},{alpha:1, x:142, ease:ease2}),"begin+=.5");			levelTl.addLabel("next",.1);			levelTl.add(TweenLite.fromTo(setupScreen.mobile.homeScreen,time,{x:-288, immediateRender:true, ease:ease1},{x:-288-462, ease:ease2}),"next" );			levelTl.add(TweenLite.fromTo(setupScreen.mobile.cardScreen,time,{x:-234+462, immediateRender:true, ease:ease1},{x:-234, ease:ease2}),"next" );			levelTl.add(TweenLite.fromTo(cardSlider,time,{alpha:0, x:sliderOrigX+462, immediateRender:true, ease:ease1},{alpha:1,x:sliderOrigX, ease:ease2}),"next" );						setupScreen.mobile.cardScreen.visible = true;			setupScreen.cardBtn.removeEventListener(MouseEvent.CLICK, chooseLevel);			cardSlider.visible = true;			setupScreen.mobile.cardScreen.dotPractise.gotoAndPlay("#on");			setupScreen.mobile.cardScreen.dotPlay.gotoAndPlay("#off");			//setupScreen.cardBtn.visible = false;						//startdrag			function setDrag(){				cardSlider.addEventListener(MouseEvent.MOUSE_DOWN, dragEasy);				stage.addEventListener(MouseEvent.MOUSE_UP, drop);			}						setDrag();			cardSlider.mouseChildren = false;			var dragMargin:Number = 350;									function dragEasy(e:MouseEvent):void			{				"PLAY SLIDE SND"								dragOrigX = cardSlider.x;				playSound(sndBtnSlide);								mouseOrigX = stage.mouseX;				trace("dragOrigX "+dragOrigX)								e.target.startDrag(false, new Rectangle(sliderOrigX+20,sliderOrigY,(sliderOrigX-(dragMargin/2)-10),0));  //sliderOrigX-sliderWidth-78			}						function drop(e:MouseEvent):void			{				trace(sliderOrigX,sliderOrigY,sliderWidth,e.target.x )				stopDrag();				cardSlider.removeEventListener(MouseEvent.MOUSE_DOWN, dragEasy);				stage.removeEventListener(MouseEvent.MOUSE_UP, drop);				//if (setupScreen.slider.x > 230 ){								//trace("distance "+distance)								if (dragOrigX == sliderOrigX-dragMargin ){ //setupScreen.slider.x > 230				TweenLite.fromTo(cardSlider, .5, {x:cardSlider.x, ease:ease1},{x:sliderOrigX, ease:ease2, overwrite:2, onComplete:setDrag}) ;				setupScreen.mobile.cardScreen.dotPractise.gotoAndPlay("#on");				setupScreen.mobile.cardScreen.dotPlay.gotoAndPlay("#off");												}				else{//if  (dragOrigX == sliderOrigX){					TweenLite.fromTo(cardSlider, .5, {x:cardSlider.x, ease:ease1},{x:sliderOrigX-dragMargin, ease:ease2, overwrite:2, onComplete:setDrag}) ;					setupScreen.mobile.cardScreen.dotPractise.gotoAndPlay("#off");					setupScreen.mobile.cardScreen.dotPlay.gotoAndPlay("#on");				}							}												cardSlider.addEventListener(MouseEvent.CLICK, selectLevel);						function selectLevel(e:MouseEvent):void{												//if (!cardSliding) {					distance = 	Math.abs(mouseOrigX-stage.mouseX)					//trace("distance "+distance)										// PLAY CARD LOCK ANIMATION, REMOVE SETUP SCREEN & DISPLAY GAME SCREEN										if (cardSlider.x >= sliderOrigX-10 && distance <10){												cardSlider.removeEventListener(MouseEvent.CLICK, selectLevel);						lockParent1.cardLock.image.gotoAndStop("prac");						lockParent1.cardSmall.gotoAndStop("prac");						lockCard("EASY")					}					else if (cardSlider.x <= sliderOrigX-(dragMargin-10) && distance <10){ //330						cardSlider.removeEventListener(MouseEvent.CLICK, selectLevel);						lockParent1.cardLock.image.gotoAndStop("play");						lockParent1.cardSmall.gotoAndStop("play");						lockCard("NORMAL"); 					}									//}							}						function lockCard(gameMode:String){				//setupScreen.visible=false;								lockParent1.gotoAndPlay("lock");				lockTl = new TimelineLite();				lockTl.addLabel("begin",0);				lockTl.add(TweenLite.fromTo(setupScreen.txt2,.5,{alpha:1},{alpha:0}) );				//if (setupScreen.txt1.alpha==1){									//}								lockTl.add(TweenLite.fromTo(setupScreen.mobile,.5,{scaleX:1,scaleY:1,alpha:1},{scaleX:.2,scaleY:.2,alpha:0}) ,"begin");				lockTl.add(TweenLite.delayedCall(.35,playSound, [sndLock]));											lockTl.add(TweenLite.delayedCall(3,gameScreen, [gameMode]));				//gameTl.add(TweenLite.fromTo(gameScreen,.5,{x:-1080},{x:0}),"next" )				//gameTl.add(TweenLite.fromTo(setupScreen,.5,{x:0},{x:1080, visible:false}),"next" )				lockTl.add(TweenLite.fromTo(setupScreen,.5,{alpha:1},{alpha:0, visible:false}), "begin")			}							}						private function onAddedToStage(e:Event):void {			removeEventListener(Event.ADDED_TO_STAGE, onAddedToStage);	  											if (XML_MODE) {				initWithXML();			} else {				//init("EASY");			}		}								// Start game loading a XML file		private function initWithXML():void {			// First time we load XML			xmlLoader.openFile("SlidingPuzzle.xml");			xmlLoader.addEventListener(Event.ENTER_FRAME, xmlLoaded);		}							// If XML file was loaded start normally, XML Mode		// If not (error reading XML file or not found), start Default Mode		private function xmlLoaded(e:Event):void {			if (xmlLoader.completedXML) {				xmlLoader.removeEventListener(Event.ENTER_FRAME, xmlLoaded);				//init();				trace("XML Loaded");			} else if (xmlLoader.errorMsg == "ERROR OPENING") {				xmlLoader.removeEventListener(Event.ENTER_FRAME, xmlLoaded);				XML_MODE = false;				//init();				trace("XML NOT FOUND");			}		}				/*private function processStartXML(e:MouseEvent):void {					}*/				private function gameScreen(dif:String):void { //e:MouseEvent)			diffLevel = dif			//trace("####diffLEvel "+diffLevel)			init(dif);						//introscreen.alpha = 0;			TweenLite.fromTo([ui,wood,puzzleHolder,hintHolder,pieceHolder], 1, {alpha:0, immediateRender:true},{alpha:1});			//Dark Dusk Filter APPLY			TweenLite.to(bg.getChildAt(1), 1, {colorMatrixFilter:{colorize:0x5686a3, amount:.9, delay:0.5}});// 7792a3											}						public function introTween():void {			introscreen.logo.gotoAndPlay(1);			introscreen.logo.alpha = 1;						introTl = new TimelineLite();			introTl.add("start", 1.5);			introTl.fromTo(introscreen.txt, .5, {x:152-1080, ease:ease1},{x:152, ease:ease2}, "start") ;			introTl.fromTo(introscreen.cta_begin, .5, {x:222-1080, ease:ease1},{x:222, ease:ease2}, "start+=.25") ;						//introTl.fromTo(mov.image2, .5, {x:222-1080},{x:222}, "start+=.") ;									setupScreen.visible = false;			//bg.vidPlayer.seek(0000);			//bg.vidPlayer.play();					}						// Init the game: draw Perlin Background, the Wood, the UI (User Interface), buttons...				private function init(dif:String):void {						// Draw the wood			wood.x = PUZZLE_X - 11;			wood.y = PUZZLE_Y - 11;			//var oldW:int = wood.width - 301;			//var oldH:int = wood.height - 301;			wood.width = PUZZLE_WIDTH + 20;			wood.height = PUZZLE_WIDTH + 20;			addChild(wood);									// Draw the back puzzle			addChild(hintHolder);			addChild(puzzleHolder);			addChild(pieceHolder);			addChild(ui);			ui.foundCard.visible=false;			ui.overlay.visible = false;			ui.overlay.alpha=0;			ui.solveBtn.alpha=0;						// Process XML			if (XML_MODE) {				processXML();				changeDifficulty(dif, true);			}									// Read Keyboard input			//stage.addEventListener(KeyboardEvent.KEY_DOWN, myOnKeyDown);			//stage.addEventListener(KeyboardEvent.KEY_UP, myOnKeyUp);												// HIDE PREV/NEXT BUTTONS 			if ( ! SHOW_PREV_NEXT_BTNS) {				ui.bPrev.visible = false;				ui.bNext.visible = false;				//ui.lightPrev.visible = false;				//ui.lightNext.visible = false;			} else {				// Show				//ui.bPrev.addEventListener(MouseEvent.CLICK, onClickPrev);				//ui.bPrev.visible = false;				//ui.lightPrev.visible = false;				//ui.bNext.addEventListener(MouseEvent.CLICK, onClickNext);			}									// Start game Loop			addEventListener(Event.ENTER_FRAME, loop);		}						// Makes the Loading Message animate		/*		private function loadingWood(e:Event):void {			//wood.loading.rotation += 7;		}*/						// If XML was loaded, process the content of the file and customize game accordingly		private function processXML(e:Event = null):void {						var myXML:XML = xmlLoader.myXML;									// Load XML Rows/Cols			//changeDim( myXML.PUZZLE_DIM.ROWS[0], myXML.PUZZLE_DIM.COLS[0] );			// End of Row/Cols						// Random ROWCols			if ( myXML.PUZZLE_DIM.RANDOM_ROWCOLS[0].toString().toLowerCase() == "true") {				RANDOM_ROWCOLS = true;			} else {				RANDOM_ROWCOLS = false;			}			// End of Random ROWCOLS															var pType:String = String(Capabilities.playerType);			if (pType == "PlugIn" || pType == "ActiveX") {/* swf is running a browser */				//Set TimeLimit				timeLimit = myXML.TIMER_LIMIT.SECONDS[0]			};						if (pType == "StandAlone" || pType == "External") {/* swf is running in a standalone Flash Player or IDE*/				timeLimit = 15;			};																								trace("timeLimit is set at "+timeLimit)												// Random Images Mode			if (myXML.IMAGES.RANDOM_IMG[0].toString().toLowerCase() == "true") {				RANDOM_IMG = true;				xmlLoader.randomMode = true;			} else {				RANDOM_IMG = false;				xmlLoader.randomMode = false;			}			// End of Random Images						// Show/Hide btns			if (myXML.SHOW_BUTTONS.DIFFICULTY[0].toString().toLowerCase() == "true") {				SHOW_DIFFICULTY_BTNS = true;				//changeDifficulty("EASY", true);			} else {				SHOW_DIFFICULTY_BTNS = false;			}			if (myXML.SHOW_BUTTONS.PREV_NEXT[0].toString().toLowerCase() == "true") {				SHOW_PREV_NEXT_BTNS = true;			} else {				SHOW_PREV_NEXT_BTNS = false;			}			// End of Show/Hide btns						// SHow Scores			if (myXML.SHOW_BUTTONS.SCORES[0].toString().toLowerCase() == "true") {				SHOW_SCORES = true;			} else {				SHOW_SCORES = false;			}		}								// This function loads the next Image to be played in the Sliding Puzzle		private function loadPuzzleImage(img:int = 0):void {			// Show the loading message			//wood.loading.visible = true;			//wood.loadingTxt.visible = true;						// XML Mode: Read XML images				if (XML_MODE) {				imageName = xmlLoader.loadImageXML(img);				cardCoord = xmlLoader.setCardTile();				cardTileX = cardCoord.cardX; //(xmlLoader.setCardTile() - 1 );				cardTileY = cardCoord.cardY; // (xmlLoader.setCardTile() - 1 );				//trace("cardTile "+cardTile)				xmlLoader.addEventListener(Event.ENTER_FRAME, onLoadedImageXML);			// FLA MovieClip containing all images in different frames			} else {				// This will choose random image				// Change TOTAL_IMAGES !!!				const TOTAL_IMAGES:int = 9;				var nxtFrame:int;				if (RANDOM_IMG) {					nxtFrame = Math.floor(Math.random() * TOTAL_IMAGES + 1);				} else {					nxtFrame = (puzzleImage.currentFrame + img);					if (nxtFrame < 1) nxtFrame = TOTAL_IMAGES;					else if (nxtFrame > TOTAL_IMAGES) nxtFrame = 1;					trace("puzzleImage frame" + nxtFrame);				}				puzzleImage.gotoAndStop( nxtFrame );				imageName = "Image" + nxtFrame;				nextPuzzle();			}		}						// Checks if the XML Image was loaded correctly and then, runs nextPuzzle()		private function onLoadedImageXML(e:Event):void {			if (xmlLoader.completed) {				xmlLoader.removeEventListener(Event.ENTER_FRAME, onLoadedImageXML);				bitmap = xmlLoader.bitmapArray[0];								// Shows the next puzzle				nextPuzzle();			}		}								// Change Difficulty Button was clicked		private function changeDifficulty(dif:String, newPuzzle:Boolean):void {			if (dif == "EASY") {				diffLevel = "EASY"				changeDim(2, 3, newPuzzle);								//chosenJumble = easy1;			} else if (dif == "NORMAL") {				diffLevel = "NORMAL"				changeDim(3, 3, newPuzzle); 			}		}						// Change the Puzzle Dimensions (Number of Rows / Cols)		private function changeDim(r:int = 0, c:int = 0, startP:Boolean = false) {			//trace("CHANGE DIM CALLED")			// Only generate a puzzle when 0.1 seconds has passed			//if (getTimer() - timerStart < 100) return;						if (RANDOM_ROWCOLS && !SHOW_DIFFICULTY_BTNS) {				r = Math.floor(Math.random() * 4 + 2);  // 2-5				c = Math.floor(Math.random() * 4 + 2);  // 2-5				if (r > 4 && c > 3) c--;				else if (c > 4 && r > 3) r--;			}			if (r < 2) r = 2;			else if (r > 7) r = 7;			if (c < 2) c = 2;			else if (c > 7) c = 7;						var rows:int = r;			var cols:int = c;						TOTAL_PIECES = rows * cols;			PUZZLE_ROWS = rows;			PUZZLE_COLS = cols;									// If function was called to Change Dim + Start New Puzzle			if (startP) {								startPuzzle();				if (diffLevel == "EASY"){										loadPuzzleImage(0);				}				else {										trace("load PLAY Image")					loadPuzzleImage(1);				}							}		}											// Starts a new puzzle: creates the pieces for the Puzzle (they are yet not shuffled)		private function startPuzzle():void {						//trace("START PUZZLE CALLED")			/*			if (RANDOM_ROWCOLS && !SHOW_DIFFICULTY_BTNS) {				changeDim();			}*/						// Clear Puzzle previous			clearScreen();			removePieces();			// End of clear puzzle						gameStarted = false;			sliding = false;						// missingPiece: 0 or LAST			if (MISSING_PIECE != "TOP_LEFT") missingPiece = TOTAL_PIECES - 1;						// Puzzle generation			puzzle = new Array();			for (var i:uint = 0; i < TOTAL_PIECES; i++) {				puzzle.push(i);			}			puzzle[missingPiece] = -1;  //no piece!			// End of puzzle generation						// Puzzle placing loop			var piece:piece_mc;			var pieceW:Number = (PUZZLE_WIDTH - (PUZZLE_COLS-1)*PIECE_MARGIN) / Number(PUZZLE_COLS) ;			var pieceH:Number = (PUZZLE_WIDTH - (PUZZLE_ROWS-1)*PIECE_MARGIN) / Number(PUZZLE_ROWS) ;						//trace("pieceW "+pieceW+", pieceH "+pieceH)												pieceHolder.visible = false;			pieceHolder.alpha = 1;			for (i = 0; i < TOTAL_PIECES; i++) {				piece = new piece_mc();				piece.width = pieceW;				piece.height = pieceH;				pieceHolder.addChild(piece);								if (puzzle[i] == -1) {					piece.alpha = 0;				}								piece.ID = puzzle[i];				//piece.txt.text = puzzle[i].toString();				piece.name = puzzle[i].toString();				piece.x = PUZZLE_X + (piece.width + PIECE_MARGIN) * (i % PUZZLE_COLS);				piece.y = PUZZLE_Y + (piece.height + PIECE_MARGIN) * (Math.floor(i / PUZZLE_COLS));								// Make every piece clickable				if (puzzle[i] != -1) {					//piece.buttonMode = true;					piece.addEventListener(MouseEvent.MOUSE_DOWN, onPieceClicked);  //CLICK				}			}			// End of puzzle placing loop		}											// Next Puzzle takes a new puzzle (not shuffled) and shuffles it		public function nextPuzzle():void		{						shuffleTl = new TimelineLite();			shuffleTl.addLabel("begin", 0);			//shuffleTl.pause();			shuffleTl.autoRemoveChildren = true;			// Start UI			// start timer					ui.timeTxt.text = convertTime(timeLimit);					totalMovs = 0;			ui.movsTxt.text = totalMovs.toString();			// end of timer			// End of UI					drawPuzzle();					// Make pieces again visibles			pieceHolder.visible = true;			//pieceHolder.getChildAt(missingPiece).visible = false;			//pieceHolder.getChildAt(missingPiece).alpha = 0;			pieceHolder.alpha = 1;									if (diffLevel=="EASY"){								ui.overlay.gotoAndStop("hints");				shuffleTl.add(TweenLite.to(ui.overlay,.05,{alpha:0, visible:true}),"begin");				shuffleTl.add(TweenLite.to(ui.overlay,time,{alpha:1}),"begin+=1");				shuffleTl.add(TweenLite.fromTo(ui.overlay,time,{alpha:1},{alpha:0, visible:false}),"begin+=5");				shuffleTl.add(TweenLite.delayedCall(.2, gameGo),"begin+=5.25");			}			else{				shuffleTl.add(TweenLite.delayedCall(.2, gameGo),"begin+=2");			}						shuffleTl.add(TweenLite.delayedCall(1, playSound,[sndHint]),"begin");			shuffleTl.to(ui.timeTxt, .2, {colorMatrixFilter:{colorize:0xFFCC00, amount:1}},"begin+=2");						for (var i:uint = 0; i < pieceHolder.numChildren; i++)			{				if (i == missingPiece)				{					continue;				}				pieceTemp = pieceHolder.getChildAt(i) as piece_mc;				pieceTemp.alpha = 1;				if (diffLevel=="EASY")				{					pieceTemp.getChildByName("hint").alpha = 0;				}				var pieceX = pieceTemp.x;				var pieceY = pieceTemp.y;				var pieceW = pieceTemp.width;				var pieceH = pieceTemp.height;				shuffleTl.add(TweenLite.fromTo(pieceTemp, TIME_SLIDING/1.5, {alpha:0, x:pieceX+(pieceW/2), rotationY:-90, immediateRender:true}, {alpha:1, x:pieceX, rotationY:0, onComplete:fixBlur, onCompleteParams:[pieceTemp, pieceX, pieceY,pieceW, pieceH]}),"begin+="+(1+(i*.1)));				if (diffLevel == "EASY")				{					trace("HINT SCALE "+pieceTemp.getChildByName("hint").scaleX+" "+pieceTemp.getChildByName("hint").scaleY)					shuffleTl.add(TweenLite.fromTo(pieceTemp.getChildByName("hint"), time, {colorMatrixFilter:{colorize:0x000000, amount:1}, alpha:1, scaleX:2, scaleY:1.66, x:25,y:0, ease:ease1}, {colorMatrixFilter:{colorize:0x000000, amount:1, remove:true},alpha:.5, scaleX:1.33, scaleY:1, x:0, y:0,ease:ease2}),"begin+="+(1.5+time+((i)*.25)));					shuffleTl.add(TweenLite.fromTo(pieceTemp, TIME_SLIDING/1.5, {alpha:1, immediateRender:false}, {alpha:0}),"begin+="+(8+(i*.1)));				} else{							shuffleTl.add(TweenLite.fromTo(pieceTemp, TIME_SLIDING/1.5, {alpha:1, immediateRender:false}, {alpha:0}),"begin+="+(5+(i*.1)));				}			}												shuffleTl.add(TweenLite.delayedCall(.05,shufflePuzzle));						// End of pieces visible;							function gameGo(){				ui.countDown.gotoAndPlay("begin");				playSound(sndGameGo);			}					// Draw the puzzle Image over the pieces								function shufflePuzzle()			{				// Shuffling loop				var pos:uint;				var changes:uint = 0;				//DISORDER_MOVES = PUZZLE_ROWS * PUZZLE_COLS * (TOTAL_PIECES * 0.6) + 17;						if (diffLevel == "EASY")				{					chosenJumble = easyJumble[cycleJumble(easyJumble,0)];				}				if (diffLevel == "NORMAL")				{					chosenJumble = medJumble[cycleJumble(medJumble,1)];				}						for (var c:uint = 0; c < chosenJumble.length; c++)				{					pos = chosenJumble[c];//Math.random() * TOTAL_PIECES;					//trace("pos "+pos)					if (puzzle[pos] == -1)					{						continue;					}					canMove(pos);					// If can, move pieces							for (var j:uint = 0; j < 4; j++)					{						if (moveArray[j])						{							movePieces(pos, j);							changes++;							break;						}					}												}				//trace("My shuffled puzzle: " + puzzle);						var pp = new PerspectiveProjection();				pp.fieldOfView = 80;						for (var h:uint = 0; h < pieceHolder.numChildren; h++)				{					if (h == missingPiece)					{						continue;					}					pieceTemp = pieceHolder.getChildAt(h) as piece_mc;					//pieceTemp.buttonMode = true;					var pieceX = pieceTemp.x;					var pieceY = pieceTemp.y;					var pieceW = pieceTemp.width;					var pieceH = pieceTemp.height;							pp.projectionCenter = new Point(pieceX+(pieceW/2),pieceY+(pieceH/2));					pieceTemp.transform.perspectiveProjection = pp;							shuffleTl.add(TweenLite.fromTo(pieceTemp, TIME_SLIDING/1.5, {alpha:.9, x:pieceX+(pieceW/2), rotationY:-90, immediateRender:true}, {alpha:1, x:pieceX, rotationY:0, onComplete:fixBlur, onCompleteParams:[pieceTemp, pieceX, pieceY,pieceW, pieceH]}),"begin+="+(.2+(h*.1)));				}												gameTl = new TimelineLite();				gameTl.add("fader", 0.2);				gameTl.fromTo(pieceHolder, .5, {alpha:0},{alpha:1, overwrite:2}, "fader") ; //,onStart:function(){ui.countDown.gotoAndPlay("begin");}				gameTl.add(TweenLite.delayedCall(2, startCountDown));				gameTl.fromTo(ui.solveBtn, .5, {alpha:0},{alpha:1}); 			}								function fixBlur(mov:piece_mc,sX:Number, sY:Number, sW:Number, sH:Number)			{				mov.transform.matrix3D = null;				mov.x = sX;				mov.y = sY;				mov.width = sW;				mov.height = sH;			}						}								public function startCountDown():void{					// Counter			timerStart = getTimer();			totalMovs = 0;			// End of counter						ui.timeTxt.visible = true;			ui.timeTxt.text = convertTime(timeLimit)			ui.movsTxt.text = totalMovs.toString();			win = false;			timeOut = false;			quit = false;			gameStarted = true;						// Show Best Score			showBestScore();						//Set Solve Btn 			ui.solveBtn.addEventListener(MouseEvent.MOUSE_DOWN, onClickSolve);		}		// Takes the position of the pieces and the Bitmap Image loaded and Draws the current Puzzle		// Also draws the Small Hint Puzzle top right, as well as the transparent Wood Hint Image		private function drawPuzzle():void {						// Delete the Loading message			//wood.loading.visible = false;			//wood.loadingTxt.visible = false;						var lastPiece:piece_mc = pieceHolder.getChildAt( pieceHolder.numChildren - 1 ) as piece_mc;						var dim:int = (lastPiece.x - PUZZLE_X + lastPiece.width);						// Draw the puzzle			var myBitmapDataObject:BitmapData = new BitmapData(dim, dim);			var myBitmap:Bitmap = new Bitmap(myBitmapDataObject);						var sp:Sprite = new Sprite();			if (XML_MODE) {				sp.addChild( bitmap );				sp.getChildAt(0).scaleX = PUZZLE_WIDTH / sp.width;				sp.getChildAt(0).scaleY = PUZZLE_WIDTH / sp.height;			} else {				sp.addChild(puzzleImage);			}			myBitmapDataObject.draw(sp);			// End of the Puzzle						//Draw the Background			var myBitmapBackground:Bitmap = new Bitmap(myBitmapDataObject);			myBitmapBackground.x = PUZZLE_X;			myBitmapBackground.y = PUZZLE_Y;			myBitmapBackground.alpha = ALPHA_HINT_WOOD;			puzzleHolder.addChild(myBitmapBackground);			//trace("mainPuzzle = " + mainPuzzle);			// End of white puzzle									// Draw all the pieces			var bmd1:BitmapData;			var rect:Rectangle;			var pt:Point = new Point(0, 0);			var bm1:Bitmap;			var w:int = pieceTemp.width;			var w2:Number = 0;			var h2:Number = 0;						if (pieceHolder.numChildren >= 1) {				w2 = lastPiece.width; 				h2 = lastPiece.height;			}						const PIECE_W:int = 70;			var scaleH:Number = PUZZLE_COLS * PIECE_W / PUZZLE_WIDTH;			var scaleV:Number = PUZZLE_ROWS * PIECE_W / PUZZLE_WIDTH;						for (var i:int = 0; i < pieceHolder.numChildren; i++) {				if (i == missingPiece) continue;								pieceTemp = pieceHolder.getChildAt(i) as piece_mc;				bmd1 = new BitmapData(w2, h2, false, 0x00222222);				rect = new Rectangle(pieceTemp.x - PUZZLE_X, pieceTemp.y - PUZZLE_Y, w2, h2);				bmd1.copyPixels(myBitmapDataObject, rect, pt);				bm1 = new Bitmap(bmd1);								bm1.scaleX = scaleH;				bm1.scaleY = scaleV;				bm1.alpha = 1;								// Remove the previous Drawings on this Piece, so only one Draw is done (saves memory)				while(pieceTemp.numChildren > 2) {					pieceTemp.removeChildAt(2);				}				pieceTemp.addChild(bm1);								hintLabel = new TextField();				hintLabel.name = "hint";    				hintLabel.selectable = false;				hintLabel.width = 20;				hintLabel.height = 20;				hintLabel.alpha=.75;								//hintLabel.border = true;    				//hintLabel.borderColor = 0x000000;  				var my_fmt:TextFormat = new TextFormat();   				my_fmt.color = 0x000000;				my_fmt.font = "AachenComWebMedium"				    			hintLabel.defaultTextFormat = my_fmt;				hintLabel.embedFonts = true;				            	hintLabel.text = (pieceTemp.ID+1).toString();								//if (diffLevel=="EASY" || diffLevel=="NORMAL" || diffLevel=="HARD"){					//hintLabel.alpha = 0;				//}				pieceTemp.addChild(hintLabel);			}			// End of draw all the pieces		}		// When clicking a piece, checks if this piece can be moved		private function onPieceClicked(e:MouseEvent): void {			if (sliding) return;						if (!gameStarted) return;						var pos:int = puzzle.indexOf(e.currentTarget.ID);						// If there is a SPACE (0), we can move pieces			// If can, move pieces			canMove(pos);			for (var i:uint = 0; i < 4; i++) {				if (moveArray[i]) {					movePieces(pos, i);					sliding = true;				}			}			// End of move pieces		}						// Moves a piece in one direction		private function movePieces(pos:uint, dir:uint): void {									var inc:int;			if (dir % 2 == 0) { //0,2 move left/right				inc = -dir + 1;				//if (gameStarted) playSound(sndTileTap);			} else { //1,3 up/down				inc = (-dir + 2) * PUZZLE_COLS;				//if (gameStarted) playSound(sndTileTap2);			}						if (gameStarted) playSound(randTileTap());						if (puzzle[pos + inc] == -1) {				movePiece(pieceHolder.getChildByName(puzzle[pos].toString()) as piece_mc,						  pieceHolder.getChildByName("-1") as piece_mc);								var pos0:uint = puzzle.indexOf(-1);				puzzle[pos0] = puzzle[pos];				puzzle[pos] = -1;			} else {				// Simultaneous movement				movePieces(pos + inc, dir);				movePieces(pos, dir);			}		}						// Checks if all pieces are correctly ordered in the right position		private function checkWin(): Boolean {			for (var i:uint = 0; i < TOTAL_PIECES; i++) {				if (puzzle[i] != i) {					if (puzzle[i] == -1 && i == missingPiece) {						//good					} else {						return false;					}				}			}			return true;		}								// This function checks all the four direction in which a piece can be moved		private function canMove(pos:int): void {						if (pos < 0 || pos >= TOTAL_PIECES) {				const MOV_DIRS:int = 4;				for (var i:uint = 0; i < MOV_DIRS; i++) {					moveArray[i] = false;				}				return;			}						moveArray[0] = canMoveRight(pos);			moveArray[1] = canMoveDown(pos);			moveArray[2] = canMoveLeft(pos);			moveArray[3] = canMoveUp(pos);			//trace("pos: " + pos + "\nRdLu: " + moveArray);		}						// Checks if a piece can be moved to the RIGHT		private function canMoveRight(pos:uint): Boolean {			for (var i:int = pos; i < pos + (PUZZLE_COLS - pos % PUZZLE_COLS); i++) {				if (puzzle[i] == -1) {					return true;				}			}			return false;		}				// Checks if a piece can be moved to the LEFT		private function canMoveLeft(pos:uint): Boolean {			for (var i:int = pos; i >= pos - (pos % PUZZLE_COLS); i--) {				//trace(puzzle[i]);				if (puzzle[i] == -1) {					return true;				}			}			return false;		}				// Checks if a piece can be moved UP		private function canMoveUp(pos:uint): Boolean {			for (var i:int = pos; i >= 0; i -= PUZZLE_COLS) {				if (puzzle[i] == -1) {					return true;				}			}			return false;		}				// Checks if a piece can be moved DOWN		private function canMoveDown(pos:uint): Boolean {			for (var i:int = pos; i < TOTAL_PIECES; i += PUZZLE_COLS) {				if (puzzle[i] == -1) {					return true;				}			}			return false;		}					// Move a piece to the new place (we already checked the movement is valid)		private function movePiece(piece:piece_mc, pieceSpace:piece_mc): void {			var swapX, swapY, swapI, swapJ, swapPos:Number;						swapX = piece.x;			swapY = piece.y;			//trace("swapX "+swapX)			//trace("swapY "+swapY)						var newX:Number = pieceSpace.x;			var newY:Number = pieceSpace.y;						piece.x = pieceSpace.x;			piece.y = pieceSpace.y;			pieceSpace.x = swapX;			pieceSpace.y = swapY;									// If the game has started, we show a Sliding Animation and Count the Moves			// If the game has not started (shuffling) this is done instantaneously			if (gameStarted) {				totalMovs++;				ui.movsTxt.text = totalMovs.toString();								//var tw:Tween;				if (swapX != newX) {					//tw = new Tween(piece, "x", Strong.easeOut, swapX, newX, TIME_SLIDING, true); 					TweenLite.fromTo(piece, TIME_SLIDING, {x:swapX},{x:newX, ease:ease2, onComplete:onFinishTweenSlide});				} else {					//tw = new Tween(piece, "y", Strong.easeOut, swapY, newY, TIME_SLIDING, true); 					TweenLite.fromTo(piece, TIME_SLIDING, {y:swapY},{y:newY, ease:ease2, onComplete:onFinishTweenSlide});				}				//tw.addEventListener(TweenEvent.MOTION_FINISH, onFinishTweenSlide);			}						if (!gameStarted) {				 //var pieceX = piece.x				//totalMovs++;				//ui.movsTxt.text = totalMovs.toString();				 //shuffleTl.add(TweenLite.fromTo(piece, TIME_SLIDING/2, {x:pieceX+(piece.width/2), rotationY:-180}, {x:pieceX ,rotationY:0})) ;  //,"+=.2" {x:swapX},				// shuffleTl.add(TweenLite.fromTo(piece, TIME_SLIDING/2, {alpha:0}, {alpha:1})) ;  //,"+=.2" {x:swapX},								/*				//var tw2:Tween;				if (swapX != newX) {					//tw2 = new Tween(piece, "x", Strong.easeOut, swapX, newX, TIME_SLIDING, true); 					 //shuffleTweens.push(new Tween(piece, "x", Strong.easeOut, swapX, newX, TIME_SLIDING/2, true) );					 trace("added tween to timelineLite")					 shuffleTl.add(TweenLite.to(piece, TIME_SLIDING/2, {x:newX, overwrite:2})) ;  //,"+=.2" {x:swapX},				} else {					//tw2 = new Tween(piece, "y", Strong.easeOut, swapY, newY, TIME_SLIDING, true); 					 //huffleTweens.push(new Tween(piece, "y", Strong.easeOut, swapY, newY, TIME_SLIDING/2, true));					 trace("added tween to timelineLite")					shuffleTl.add(TweenLite.to(piece, TIME_SLIDING/2, {y:newY, overwrite:2})) ; //autoRemoveChildren:true, immediateRender:false,				}*/				//tw2.addEventListener(TweenEvent.MOTION_FINISH, onFinishTween2Slide);			}														}						// This happens when the Piece finished sliding to the new position		private function onFinishTweenSlide():void { //e:TweenEvent			//e.currentTarget.removeEventListener(TweenEvent.MOTION_FINISH, onFinishTweenSlide);			sliding = false;						// Check if the puzzle is done (WIN game)			if (checkWin()) {				trace("WIN!");				win = true;				for (var j = 0; j < pieceHolder.numChildren; j++) {					pieceTemp = pieceHolder.getChildAt(j) as piece_mc;					//pieceTemp.removeEventListener(MouseEvent.CLICK, onPieceClicked);					pieceTemp.buttonMode = false;				}			} // End of check if puzzle is done		}						/*		// This happens when the Piece finished sliding to the new position		private function onFinishTween2Slide(e:TweenEvent):void {			e.currentTarget.removeEventListener(TweenEvent.MOTION_FINISH, onFinishTween2Slide);			sliding = false;					}*/												// For Debug		private function traceBoard(): void {			for (var i:uint = 0; i < TOTAL_PIECES; i += PUZZLE_ROWS) {				trace(puzzle[i] + " " + puzzle[i+1] + " " + puzzle[i+2] + " " + puzzle[i+3]);			}		}						/*		// Reads Keyboard pressed keys		private function myOnKeyDown(e:KeyboardEvent): void {			if (sliding) return;			if (win || !gameStarted) return;						var index:int = _keysPressed.indexOf(e.keyCode); 			if (index >= 0) {				_keysDown[index] = 3;			} else {				_keysPressed.push(e.keyCode);				_keysDown.push(1);			}						// If key pressed long, wait a bit... 			// This way we don't have one (long) pressed key unvoluntarily move 2 pieces			if (getTimer() - lastMovTime < KEY_HOLD_TIME) return;						// Check if pressed UP, LEFT, RIGHT or DOWN and canMove			var pos:int = puzzle.indexOf(-1);			if (isKeyDown(_KEY_RIGHT) && pos > 0) {				pos--;			} else if (isKeyDown(_KEY_LEFT) && pos < TOTAL_PIECES - 1) {				pos++;			} else if (isKeyDown(_KEY_DOWN) && pos >= PUZZLE_COLS) {				pos -= PUZZLE_COLS;			} else if (isKeyDown(_KEY_UP) && pos + PUZZLE_COLS <= TOTAL_PIECES - 1) {				pos += PUZZLE_COLS;			}			// If NOT move available, return			if (pos == puzzle.indexOf(-1)) return;						// If there is a SPACE (0), we can move pieces			// If can, move pieces			canMove(pos);			for (var i:uint = 0; i < 4; i++) {				if (moveArray[i]) {					lastMovTime = getTimer();					movePieces(pos, i);					sliding = true;				}			}			// End of move pieces		}		// Key was released		private function myOnKeyUp(e:KeyboardEvent): void {			//if (sliding) return;			var index:int = _keysPressed.indexOf(e.keyCode); 			if (index >= 0) {				_keysPressed.splice(index, 1);				_keysDown.splice(index, 1);			}						if (_keysPressed.length == 0) {				lastMovTime = 0;			}		}		// Checks if a certain key is down		public function isKeyDown(k:uint):uint {			if (_keysPressed.length == 0) return 0;						var index:int = _keysPressed.indexOf(k);			if (index == -1) return 0;			return _keysDown[index];		}		*/				// Clears the screen		private function clearScreen():void {			while(puzzleHolder.numChildren > 0) puzzleHolder.removeChildAt(0);		}						// Removes all pieces of a puzzle		private function removePieces(): void {			while(pieceHolder.numChildren > 0) {				(pieceHolder.getChildAt(0) as piece_mc).removeEventListener(MouseEvent.CLICK, onPieceClicked);				pieceHolder.removeChildAt(0);			}		}								// Game Loop, On Enter Frame		private function loop(e:Event): void {			stage.focus = stage;																	// If win, OR TIMEOUT Tween the Puzzle completed			if (win || timeOut || quit) {				//if (findCardTl == null) {					if (win || quit){						sndChTimer.stop();					}										removeEventListener(Event.ENTER_FRAME, loop);					ui.solveBtn.removeEventListener(MouseEvent.MOUSE_DOWN, onClickSolve);					findCardTl = new TimelineLite();					findCardTl.addLabel("begin", 0);					findCardTl.fromTo(ui.solveBtn, time, {alpha:1},{alpha:0},"begin+=.25"); 					//Tween Tile containing CreditCard					//trace("imageCardTile "+xmlLoader.imageCardTile);					//trace("cardTile "+cardTile+" X: "+pieceHolder.getChildAt(cardTile).x+ " Y:" +pieceHolder.getChildAt(cardTile).y )					if (timeOut){						ui.overlay.visible=true;						ui.overlay.gotoAndStop("timeOut");						findCardTl.add(TweenLite.fromTo(ui.overlay, .5, {alpha:0}, {alpha:1}),"begin+=0.1") ;						//findCardTl.add(TweenLite.fromTo(ui.overlay, .5, {alpha:1}, {alpha:0,visible:false}),"begin+=4") ;						findCardTl.add(TweenLite.to(ui.overlay, .5, {alpha:0, visible:false}),"begin+=2.5") ;					}										 //onStart:playSound,onStartParams:[sndFoundCard]					findCardTl.add(TweenLite.fromTo(ui.foundCard, 1, {alpha:0,x:PUZZLE_X+cardTileX, y:PUZZLE_Y+cardTileY, visible:true,scaleX:3, scaleY:3}, {alpha:.66,scaleX:1, scaleY:1}),"+=2") ;								findCardTl.add( TweenLite.delayedCall(.1, playSound,[sndFoundCard]),"-=1.5");					findCardTl.fromTo(pieceHolder, .5, {alpha:1},{alpha:0, overwrite:2, immediateRender:true},"begin") ;					findCardTl.add(TweenLite.fromTo(puzzleHolder.getChildAt(0), .5, {alpha:0},{alpha:1, overwrite:2}),"begin") ; //,"next"					findCardTl.add( TweenLite.delayedCall(1, onFinishFindCard)); 																			// Save Score					//Score.saveScore(imageName, (PUZZLE_ROWS+"x"+PUZZLE_COLS).toString(), totalTimer, totalMovs);				//}			// Else, show the time ellapsed			} else if (gameStarted) {				//totalTimer = (getTimer() - timerStart) * 0.001;				totalTimer = timeLimit - ((getTimer()-timerStart)* 0.001);								ui.timeTxt.text = convertTime(totalTimer);												if (totalTimer < 11){										colourPulse();					pulseAlready = true;														}								if (totalTimer==0){					timeOut= true					pulseAlready = false;									}							}					}						private function colourPulse():void{			if (totalTimer==10){								if (!pulseAlready) {					timerPulseTl = new TimelineMax({repeat:10});					trace("COLOURPUALSEDDDDD");					sndChTimer = sndTimer.play();					timerPulseTl.to(ui.timeTxt, .3, {colorMatrixFilter:{colorize:0x000000, amount:1}}) ;					timerPulseTl.to(ui.timeTxt, .699, {colorMatrixFilter:{colorize:0xFFCC00, amount:1}});				}			}		}						private function convertTime(sec:int):String{						if (sec%60 == 0){				return String(Math.floor(sec/60)+":00")			}			else if (sec%60 < 10){				return String(Math.floor(sec/60)+":0"+sec%60)			}			else{				return String(Math.floor(sec/60)+":"+sec%60)			}		}				// Finished WIN Tween		private function onFinishFindCard():void { //e:TweenEvent			//removeEventListener(Event.ENTER_FRAME, loop);			//myTween.removeEventListener(TweenEvent.MOTION_FINISH, onFinishTween);						//myTween = null;			findCardTl.kill();			showWinPopUp();		}								// Shows your Best Score for this Puzzle and Dim		private function showBestScore():void {			// Show Score			ui.bestScoresTxt.text = "";						if (SHOW_SCORES) {				var loadScores:Array = Score.loadScoresByImageDim(imageName, (PUZZLE_ROWS+"x"+PUZZLE_COLS).toString());				if (loadScores) {					ui.bestScoresTxt.text = "** BEST SCORE **    " + "TIME: " + loadScores[2] + "   MOVS: " + loadScores[3];				}			}			// End of show score		}		// Shows the WIN Pop up		private function showWinPopUp():void {			winTl = new TimelineLite();			/*winPopUp.clipboardbutton.addEventListener(MouseEvent.CLICK, function(){				trace("Copy Results");				//System.setClipboard("Time completed: " + totalTimer.toString());				System.setClipboard("Level Completed: " + diffLevel.toString()+"\n"+"Elapsed Time: " + totalTimer.toString()+" seconds"+"\n"+"Number of Moves: " + totalMovs.toString());			});			*/						if (win){								winPopUp.bestScoresTxt.text = "CONGRATULATIONS!"				winPopUp.timeTxt.text = convertTime(timeLimit-totalTimer)//totalTimer.toString();				winPopUp.movsTxt.text = totalMovs.toString();				trace("totalMovs = " + totalMovs);				if (diffLevel=="EASY"){					winPopUp.bNext.btnLabel.text = "Play for real";					winPopUp.bodyTxt.gotoAndStop("pracWin");					winPopUp.doneBtn.visible = true;				}				else {					winPopUp.bNext.btnLabel.text = "Play again";					winPopUp.bodyTxt.gotoAndStop("playWin");					winPopUp.doneBtn.visible = false;				}			}						if (timeOut || quit){								winPopUp.bestScoresTxt.text = "WE'VE FOUND"+"\n"+"YOUR CARD!"				winPopUp.timeTxt.text = convertTime(timeLimit-totalTimer)//totalTimer.toString();				winPopUp.movsTxt.text = totalMovs.toString();				if (diffLevel=="EASY"){					winPopUp.bNext.btnLabel.text = "Play for real";					winPopUp.bodyTxt.gotoAndStop("pracLose");					winPopUp.doneBtn.visible = true;				}				else {					winPopUp.bNext.btnLabel.text = "Play again";					winPopUp.bodyTxt.gotoAndStop("playLose");					winPopUp.doneBtn.visible = false;				}			}						winPopUp.name = "WinPopUp";			addChild(winPopUp);			removePieces();			//TRANSITION - SLIDE GAME UI ACROSS			winTl.to([ui,wood,puzzleHolder,hintHolder,pieceHolder], 1, {alpha:0, onComplete:function(){lockParent1.gotoAndPlay("unlock");lockParent2.gotoAndPlay("unlock");}});			winTl.addLabel("next",1.5);			winTl.to(ui.timeTxt, .1, {colorMatrixFilter:{colorize:0xFFCC00, amount:1}},"next");			//Dark Dusk Filter REMOVE			winTl.to(bg.getChildAt(1), 1.5, {colorMatrixFilter:{colorize:0x5686a3, amount:0, remove:true}},"next");			//endTl.fromTo(bg.getChildAt(1),time,{x:-100, ease:ease1},{x:-200,ease:ease2},"begin+=.2");			//winTl.fromTo(bg.getChildAt(1),1,{x:-100, ease:ease1},{x:-200,ease:ease2},"next");			winTl.fromTo(winPopUp, 1.5, {alpha:0},{alpha:1, onComplete:onFinishPopUp},"next");			if (win) winTl.add(TweenLite.delayedCall(.25,playSound,[sndWin]),"next")			if (timeOut || quit) winTl.add(TweenLite.delayedCall(.25,playSound,[sndTimeOut]),"next")			winTl.add(TweenLite.delayedCall(.25,playSound,[sndLock]))		}						// Win Pop Up completely shown		private function onFinishPopUp():void {			winPopUp.bNext.addEventListener(MouseEvent.MOUSE_DOWN, onClickPopUpNext);			winPopUp.doneBtn.addEventListener(MouseEvent.MOUSE_DOWN, onClickPopUpNext);						reset_interval = setInterval(forceReset, 20000);					}				private function forceReset(){			winPopUp.doneBtn.dispatchEvent(new MouseEvent(MouseEvent.MOUSE_DOWN, true, false))		}				/*private function onClickDoneBtn(e:MouseEvent):void {			winPopUp.doneBtn.removeEventListener(MouseEvent.MOUSE_DOWN, onClickDoneBtn);						//RESET!!!		}*/				private function onClickReset(e:MouseEvent):void {			//RELOAD SWF   			var url:String = stage.loaderInfo.url;    		var request:URLRequest = new URLRequest(url);   			navigateToURL(request,"_level0");		}				private function onClickSolve(e:MouseEvent):void {			playSound(sndBtnClick);			ui.solveBtn.gotoAndPlay("on");			ui.solveBtn.removeEventListener(MouseEvent.CLICK, onClickSolve);			quit = true;					}				private function onClickPopUpNext(e:MouseEvent):void {						clearInterval(reset_interval);						switch (e.currentTarget.name){							case "doneBtn":				winPopUp.doneBtn.gotoAndPlay("on");				//FORCE GAME TO RESET				diffLevel = "NORMAL";				break;							case "bNext":				winPopUp.bNext.gotoAndPlay("on");			}						winPopUp.doneBtn.removeEventListener(MouseEvent.MOUSE_DOWN, onClickPopUpNext);			winPopUp.bNext.removeEventListener(MouseEvent.MOUSE_DOWN, onClickPopUpNext);													//trace("####diffLEvel "+diffLevel)			endTl = new TimelineLite();			endTl.addLabel("begin",.2);			if (diffLevel=="EASY"){				lockParent2.cardLock.image.gotoAndStop("play");				lockParent2.cardSmall.gotoAndStop("play");								// PLAY CARD LOCK ANIMATION, SWITCH CARDS, THEN REMOVE WINPOPUP				endTl.fromTo(lockParent1,time,{x:lockPrnt1OrigX, ease:ease1},{x:lockPrnt1OrigX+1080, ease:ease2},"begin")				endTl.fromTo(lockParent2,time,{x:lockPrnt2OrigX, ease:ease1,onStart:function(){lockParent2.gotoAndPlay("zoom");lockParent2.cardLock.gotoAndPlay("#animate");}},{x:lockPrnt2OrigX+1080, ease:ease2},"begin")				endTl.fromTo(winPopUp,time,{alpha:1, ease:ease1},{alpha:0, ease:ease2 },"begin")				endTl.add(TweenLite.delayedCall(.1,playSound,[sndLock]),"begin+=0.9");				endTl.add(TweenLite.delayedCall(.5,removeWinPopUp),"begin+=1.5");				endTl.add(TweenLite.delayedCall(1, gameScreen, ["NORMAL"]),"begin+=1.5");			}						else if (diffLevel=="NORMAL"){				diffLevel = "EASY";				trace("END OF NORMAL GAME")				// PLAY CARD LOCK ANIMATION THEN REMOVE WINPOPUP				introscreen.logo.alpha=0;				introscreen.logo.gotoAndStop(1);				endTl.fromTo([lockParent1,lockParent2],time,{alpha:1, ease:ease1},{alpha:0, ease:ease2},"begin");				endTl.fromTo(winPopUp,time,{alpha:1, ease:ease1},{alpha:0, ease:ease2}, "begin");								endTl.add(TweenLite.delayedCall(.5,removeWinPopUp),"begin+=.5");				endTl.add(TweenLite.delayedCall(.5,reset),"begin+=.5");							}		}				// Remove the Win Pop Up		private function removeWinPopUp():void {			//winPopUp.bPrev.addEventListener(MouseEvent.CLICK, onClickPopUpPrev);			pulseAlready = false;			removeChild(winPopUp);			win = false;			timeOut = false;			quit = false;			gameStarted = false;  //true;			//addEventListener(Event.ENTER_FRAME, loop);		}								private function cycleJumble(a:Array, j:int): int {			var count:int = currentJumble[j];			if (count == (a.length-1)){				count = 0;				currentJumble[j] = count			}			else {				count++				currentJumble[j]  = count			}			trace("Jumble Count "+count)			ui.jumbleID.text="Jumble Number "+(count+1);			return count		}						public function randRange(start:Number, end:Number) : Number {		   return (Math.floor(start +(Math.random() * (end - start))));		}				public function randTileTap():Sound{			var num = randRange(1,5);			var snd:Sound;			switch (num){				case 1:				snd = sndTileTap				break;				case 2:				snd = sndTileTap2				break;				case 3:				snd = sndTileTap3				break;				case 4:				snd = sndTileTap4				break;				case 5:				snd = sndTileTap5				break;							}						return snd;		} 	}	}